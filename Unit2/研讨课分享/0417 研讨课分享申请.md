OO研讨课分享提纲

## 第六/七作业的整体架构是怎么设计的？

整体架构设计为输入线程-分发线程-电梯线程，其中：

- 电梯的调度策略使用了影子电梯，与分发线程进行了分离，在电梯分发乘客时向影子电梯管理类发送请求，得到相应的电梯id
- 电梯的运行策略为look算法，与电梯线程进行了分离，在运行时向策略类进行请求，得到下一步的运行策略
- 电梯与电梯线程进行了分离，使得代码较为简洁

其中，我的调度策略采用了影子电梯。在第六次作业中由于是单轿厢电梯，较好模拟，可以使用单线程完整模拟加入乘客后的所需运行时间。在第七次作业中的双轿厢电梯中，由于涉及**双轿厢的换乘问题**，如何使两个轿厢的运行同步，在单线程中模拟多线程的并发特点，我是用了**自定义时钟的状态机方法**来模拟双轿厢的换乘问题。

通过在影子电梯中实现一个全局时钟，通过状态机的逻辑实现了相应的换乘逻辑，实现了**在单线程中模拟多线程的同时运行效果**，能够较为准确地模拟电梯的运行效果。

![uml](https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202404151125351.png)

## 怎样在迭代开发中保持高内聚/低耦合？

我是将电梯线程与电梯、电梯的调度策略进行分离。实现高内聚、低耦合的特点。

在迭代开发的过程中，这样可以将reset请求也作为电梯的一种调度策略，在方法上是和move等行为等价的，不需要在架构上进行改变，可以视作对电梯的一种操作。

同时，为了保持整体的架构不需要做出较大的调整，我使用了**面向接口进行编程**的思路。比如在电梯reset期间需要加入乘客怎么办，我在等待队列这个类中实现了一个缓冲队列，这样可以保证相关类的对外表现不需要做出改变，只需要改变提供接口的类的内部逻辑即可。

在迭代过程中，我的影子电梯内部实现方法进行了较大的改变，近似于全部重写了一遍，但由于**对外提供的接口没有改变**，不需要改变外部的逻辑，只需要保证对外提供的接口的正确性即可。

并且，**将电梯和电梯线程进行分离**，保证了相应的高内聚低耦合特点，电梯线程负责宏观上的操作，电梯进行更为具体的操作，保证了代码的简洁，逻辑性上也更好。

## 对于reset和双轿厢问题是怎么解决的？

在第六七次作业中，最显著的变化就是引入了reset方法，能够改变电梯相关的属性。

我的架构中将电梯和电梯线程进行了分离，基于多态将reset请求也作为向电梯线程发起的一种请求，通过类似于*转发*的方式使得电梯能够第一时间响应reset请求。将reset方法作为电梯调度过程中的一个方法，和move等方法同等地位。

对于一般的reset请求，只需要sleep1.2s，在结束后改变相应属性即可。对于双轿厢请求，我的方法是再开启一个线程，与原来的电梯共享一个等待队列。

这样操作的好处在于，在没有开启双轿厢时，不会有对另一个轿厢的频繁唤醒，减少了可能出现的ctle，并且更符合实际的运行逻辑：变成了双轿厢就再增加一个轿厢。

通过共享一个等待队列，依然使用了面向接口编程的方法，两个轿厢向等待队列申请乘客、释放乘客的操作都是等价的，通过统一的方法保证了相关类的多线程安全，并且在架构上做到了高内聚低耦合的特点。
