# 面向对象设计与构造第14次作业

## 第一部分：训练目标

本次作业以一个图书馆管理系统为背景，锻炼同学们**对程序架构的设计和抽象能力，以及UML建模能力**。

## 第二部分：预备知识

同学们需要掌握 **UML 图**的相关知识以及 **StarUML 的使用方法**。这里给出一些**参考资料**。

[第四单元手册](http://gitlab.oo.buaa.edu.cn/2024_oo_public/guidebook/homework_13)

同学亦可参阅OO工具链教程的文末部分：

[OO工具链教程](http://gitlab.oo.buaa.edu.cn/2024_oo_public/course_system_guidebook/-/blob/main/%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%84%E9%80%A0%E3%80%8B%E5%B7%A5%E5%85%B7%E9%93%BE%E6%95%99%E7%A8%8B.md)

## 第三部分：题目描述

在一所小型图书馆中，用户借阅图书需要遵守一定的规章制度。我们需要你模拟一个小型的图书管理系统，完成图书馆所支持的相关业务。

图书馆书架上的所有图书按照 **“类别号-序列号”** 的形式编制**书号**（同学们可以理解为 ISBN 国际标准书号的简化形式，即一本书的书号是唯一的，它的所有副本的书号都是相同的）。图书分 A、B、C 三类，每种类别可能包含多个图书，每个图书可能具有多个副本（具有相同书号的两本书籍是同质的）。对于不同类别的书，有不同的借阅数量限制。

图书馆的运行分为两个时段：白天**开馆**，夜晚**闭馆**。开馆后，图书管理系统需要处理用户的**各种请求**，依据图书馆的**运行规则**决定是否批准用户的请求；同时，开馆时和闭馆时，图书馆内部依据需要**整理各部门的图书**，以满足接下来可能处理的各种请求。

在上次作业中，开馆时图书管理系统需要处理的请求包括：借书、还书、查询、预约和预约取书。

**本次作业新增的情况有：续借，图书漂流；新增的限制有：图书借阅期限限制。**



### 一、流程描述

**重要概念说明**：

- 本次作业中，我们规定：
  - 在架正式书籍仅可以存在于如下四个位置：**书架**、**预约处**、**借还处**、和**用户**。
  - 图书漂流角内的非正式书籍仅可以存在于如下三个位置：**借还处**、**图书漂流角**和**用户**，详情见后。
- 图书馆系统提供**自助查询机**查询书籍状态。
- 图书馆开馆后接收用户请求，输出处理结果；开馆和闭馆整理图书时，输出图书的转运路径。

#### 借阅流程

若一位用户来到图书馆借阅某书籍，按照如下规则进行处理：

1. 若欲借阅的书籍无余本在架，借阅失败；
2. 若欲借阅的书籍为 **A 类书籍**，借阅失败（ A 类图书无法借阅）；
3. 若欲借阅的书籍为 **B** **类或 C 类书籍**，该用户会前往**借还处**登记。**借还处**会检查该用户所持有的书籍数量是否**符合借阅数量限制**（见后）。若符合则借阅成功，该用户从此刻起持有该书；否则借阅失败，书籍被扣在**借还处**，借还处从此刻起持有该书；
  

**新增**：**若欲借的书籍为图书漂流角的非正式书籍，借阅规则见后。**

#### 还书流程

若一位用户来到图书馆归还某书籍，则该用户会前往**借还处**，在本次作业中还书立即成功，从此刻起，借还处持有该书，用户不再持有该书。

**新增：注意还书时需要确认是否逾期，关于逾期的输出见后**

#### 预约流程

若一位用户需要预约某书籍，则该用户需要前往**预约处**登记。

1. 该用户必须满足下述要求才可以预约成功：
   - 预约的书不是 A 类书（规定 A 类书无法预约）。
   - 若已经持有一本 B 类书，则无法再预约任何 B 类书。
   - 若已经持有**某书号**的 C 类书，则不能预约**该书号**的 C 类书。
   - 若当前**没有持有** **B 类书**，可以**预约任意数量的** **B 类书**（ B 类书只要求用户不可以持有两本及以上，但预约不算在其中）。
   - 若当前**没有持有某书号的 C 类书**，就可以**预约任意数量该书号的 C 类书**。
2. 预约成功后，图书馆可在此后的整理流程中选择将书送至预约处，送至预约处的图书需要指定是为了满足哪个用户的预约请求而送达的，具体输出格式见后。
3. 图书送至预约处后，若在**开馆后整理**中送达，则从**当日**起为该用户保留 **5** 天；若在**闭馆后整理**中送达，从**次日**起为该用户保留 **5** 天。在此期间，该书不能在整理流程中移动。第五天闭馆时，该书不再视作为该用户保留，视为预约失效。从次日起，预约该书的用户将无法取走该书，图书馆可对该书进行整理。例如1月1日开馆后送达，则1月5日闭馆后，该书不再为用户保留；1月1日闭馆后送达，则1月6日闭馆后，该书不再为用户保留。

**新增：图书漂流角的非正式书籍不可预约，规则见后。**

#### 取书流程

用户只能去预约处取书。

若预约处存在一本为该用户保留的图书，且取书后该用户持有的书仍然满足借阅数量限制，则该用户取书成功，即刻起由用户持有该书，且该用户对于该书的最早的一个成功预约视作完成，不再生效。否则取书失败，书籍不发生移动。

取书时，对于用户要取的这本书，如果预约处存在多本，默认取走**最早送达预约处**的一本。

#### 查询流程

若用户需要查询图书馆内在架书籍和图书漂流角内书籍的信息，可前往**自助查询机**处查询：

- 对于书架上的正式图书，查询某书号的书的**在架**余本数。
- **新增：对于图书漂流角的非正式图书，查询漂流角内某书号书的余本数。**

#### 整理流程

每次开馆和每次闭馆后，系统都有一次机会整理各处的图书，此时系统可以在不违反规则的情况下任意移动图书馆内的可在整理流程中移动的图书（整理的目的是为了满足请求，只要不违反限制，也可以不移动图书）。

为了保证图书馆的借阅成功率，对整理图书进行如下限制：
1. 在开馆对应的整理后（即在 OPEN 指令对应的整理后），借还处不应该有书，预约处不应该有逾期的书。
2. 不可以为没有预定特定书籍的用户预留该书籍（即为该用户将该书籍送至预约处）。
3. 同学们可以自由考虑使用何种策略为预约预留书籍（没有特别限制，但建议以提高借阅成功率为目的），但是不允许无条件拒绝为预约预留书籍。

**新增：图书漂流角内非正式图书的移动限制**。

4. 在开馆对应的整理后（即在 OPEN 指令对应的整理后），图书漂流角不能有需要升级（借还次数达到2次）的非正式图书。具体的，对于借还处的漂流角非正式书籍，当其完整借阅次数达到两次，应将其移动到**书架**（移动到书架的同时视作升级为正式书籍），否则因整理规则1，应将其移回图书漂流角。

#### 续借流程

当一位用户持有某书时，可在还书期限的前**5天**内办理续借手续。即1月30日为还书不逾期的最后一天时，26-30日开馆后可办理续借手续。提前办理或逾期办理皆会失败。

续借时，若存在任意一位用户对该书**正在生效的**预约（从预约成功开始，直到取书成功预约完成前，或送书后一直未取书导致预约失效前）且该书无在架余本，则续借失败。除此种情况外，用户续借成功，该书的借阅期限延长30天，例如原本应在3月1日及以前还书，续借成功后还书期限延长至3月31日。

#### 图书漂流

本次作业中，我们的图书馆新增了图书漂流功能。用户可以捐献图书到图书馆的漂流角，也可以前往漂流角借阅图书，捐献到漂流角的图书归图书馆所有。当一本图书被用户多次借阅，图书馆会将其视作热门图书，正式列为图书馆的在馆管理图书。

具体的规则描述如下：

1. 若一位用户打算捐献图书，将前往图书漂流角，用户不能捐献从图书馆借阅的书籍，且捐献的书籍编号一定不与图书馆的任意正式书籍相同。**捐献一定成功**。
2. 捐献成功后，漂流角将持有该书。捐献图书的编号与图书馆正式书籍有所不同，具体的，捐献的图书类别号为AU，BU，CU三种，序列号仍然为四位数字，详细格式见输入输出部分。
3. 借阅漂流角的图书和借阅书架上的图书流程类似，借阅AU类图书或无对应书籍时直接失败（不会导致图书移动），否则前往借还处办理手续，若用户满足图书借阅数量限制，则借阅成功，用户从即刻起持有该书，否则借阅失败，书籍将被扣在借还处。特别注意漂流角图书的**借阅期限**与正式图书**有所不同**，且**不能被预约和续借**。
4. 用户借阅了一本漂流角的书后，需要前往**借还处**归还，归还成功后，记录该书在漂流角被完整借还一次。
5. **开馆后的整理流程中**，借还处会统计所有来自于漂流角的书籍的借还次数，当某书的借还次数达到**2次**，则**必须**将其**送往书架**，该书即刻起成为图书馆的正式在架书籍，类别号去掉U，序列号不变（如BU-0001->B-0001），此后可以接受预约，续借等请求；借还若未达到2次，则必须将其送回漂流角。



### 二、规则描述

#### 图书借阅数量限制

- A 类书和AU类书：仅能在图书馆阅览，不可借阅，不可预约。
- B 类书：一人同一时刻仅能持有一个 B 类书的副本。
- BU 类书：一人同一时刻仅能持有一个 BU 类书的副本。
- C 类书和CU类书：对于每一个书号，一人同一时刻仅能持有一个具有该书号的书籍副本。

#### 图书移动限制

任何可以**引起图书位置变化**的操作，该书数量的变化**符合实际**（一次移动仅可以改变单一副本的位置，本次作业中只有捐献书籍可以引起图书总数增加，其余操作前后图书总数不变）。

具体的，此次作业中，可以引起图书位置变化的操作如下：

* 用户借阅书架图书成功：书架 -> 用户
* 用户借阅书架图书失败（仅限借阅流程的情况3）：书架 -> 借还处
* 用户取书：预约处 -> 用户
* 用户还书：用户 -> 借还处
- 用户借阅漂流角图书成功：漂流角->用户
- 用户借阅漂流角图书失败：漂流角->借还处
* 整理时的**正式**图书转运：借还处，书架，预约处这三个位置中从一个位置到另一个位置
- 整理时图书漂流相关的**非正式**图书转运：借还处->漂流角，借还处->书架

#### 借阅期限限制

图书的**借阅期限**规定如下：

- A类图书和AU类图书不可借阅或移动，没有借阅期限的概念

- B类图书借阅期限为30天
- C类图书借阅期限为60天
- BU类图书借阅期限为7天
- CU类图书借阅期限为14天

若某书的借阅期限为 x 天，自用户拿到借阅书本（包括**借阅成功**和**取书成功**）的次日起算第 1 日，第 x 日当日还书不算超期。例如借阅期限30天，用户于1月1日借阅成功，则1月31日还书不算逾期，2月1日还书算作逾期。



## 第四部分：评测标准

### 程序评测

本单元对程序正确性的检查仍采用**交互式评测**。具体的，我们的测试数据点只给出**借书请求**，**预约请求**，**查询请求**和**捐献请求（新增）**，而**还书请求**，**取书请求**和**续借请求（新增）**依据同学们的输出情况动态生成，以检测同学们的程序是否能够正确处理不同情况的请求。

* 评测机保证一定是针对拥有某书的相应用户来生成该书的还书请求。对每条成功的借书请求和成功的取书请求，**至多生成 1 条**对应的续借请求，**至多生成 1 条**对应的还书请求。都生成时，保证续借请求在还书请求**之前**。
* 评测机保证一定是某个用户对某书的预约成功之后才生成该书的取书请求，但不确定该请求发出时相应的图书是否送达预约处。对每条预约请求，**至多生成 2 条**取书请求。

### 类图

类图的评测规则如下：

* R1：类图正确性基本检验
	* 类图中的所有元素，除 direction 为 return 的 UMLParameter ，UMLAssociation ，UMLAssociationEnd ，UMLGeneralization ，UMLInterfaceRealization 外，其余元素的 name 字段不能为空。
	* 不能含有重名的类。
	* 不能有循环继承。
	* 任何一个类或接口不能重复继承另外一个类或接口。
	* 接口的所有属性和方法均需要为 public 。
* R2：类图与程序一致性检验（类内部对应关系）（Class 正确性检验）
	* 类图与程序能互相找到名字相同的类。
	* 类图中每个类的属性：考察它们是否与程序中类的属性的**名字、可见性、类型**一致。
	* 类图中每个类的方法：考察它们是否与程序中类的方法的**名字、可见性、返回值类型**一致。
* R3：类图与程序一致性检验（类内部对应关系）（Interface 正确性检验）
	* 与 R2 中检测 class 的条目一致。
* R4：类图与程序一致性检验（类内部对应关系）（Enum 正确性检验）
	* 与 R2 中检测 class 的条目一致。
	* 额外的，类图中所定义的**枚举项**要求与代码中相应枚举类所定义**枚举项**名称相同，且是一一对应。
* R5：针对关系的类图与程序一致性检查
	* 类图中的**继承、实现、关联**关系应和代码实现中的关系保持一致，即同时存在或同时不存在。

关于 UML 类图和程序一致性的检查，有以下说明：

* 对于所提交的 UML 类图和所提交程序
	* 设类图中的设计单元集合为 MC ，程序中的实现单元集合为 CC
	* “单元”包括 class ，interface ，enum class
* 对于 MC 中任意一个单元 Ma
	* Ma 中属性个数或方法个数不少于 1
	* CC 中一定存在一个单元 Ca 与 Ma 相对应，且 Ma 中属性数目不少于 Ca 中属性数目的 60% ，同时 Ma 中方法数目不少于 Ca 中方法数目的 60%
* 对于 CC 中的任意一个单元 Ca
	* MC 中必然存在一个单元 Ma 与之相对应
* 对于 MC 中任意两个单元Ma和Mb的关系 Rab
	* CC 中必然有对应的两个单元 Ca 和 Cb ，且 Ca 和 Cb 同样具有相同的关系 Rab ，反之亦然

对于关联关系的补充说明：

* 在程序中，如若一个设计单元 Ca 的成员属性引用了设计单元 Cb ，我们认为 Ca 、Cb 之间存在关联关系。
* 在 UML 类图中的关联关系，既可以通过设计单元的属性引用隐式描述（属性类型是设计单元），也可以用 UMLAssociation 来显式描述。
* 建议在画图时，将重要的关联关系使用 UMLAssociation 进行描述，更便于理解设计单元之间的关系。

### 状态图

本次作业中，我们要求同学们自行设计书籍的状态并绘制状态图，状态图的评测规则如下：

- R1：状态图正确性基本检验

  - 状态图中只能有一个起始状态和0到1个终止状态

  - 起始状态只能有外出迁移，终止状态只能有进入迁移
  
- R2：Trigger与Guard检验

    - 除了起始状态的外出迁移，所有状态转移中Trigger和Guard至少要存在一个
    
    - 任意一个迁移的Guard所涉及的变量，都必须是程序中某个类的成员变量
    
    - 从一个状态转移到不同状态的Guard条件必须互斥（无论Trigger是否相同）
    - **状态图中迁移的Trigger必须和程序中有@Trigger注解的方法一一对应**（具体要求见后）
    
- R3：状态转移路径检验
    - 任意一个状态S，必然存在一条迁移路径（起点为起始状态，终点为S）
    - 任意一个状态S，必然存在一条路径迁移到终止状态（如果有）
    - 针对每个状态S，从起始状态到S的所有简单路径都必须有解
       - 路径有解：该路径上所有转移的Guard在一起（逻辑与）有解
       - 简单路径：路径中所有迁移循环走0次或1次

**关于程序中注解的添加方法说明**

对于程序中涉及到状态转移的方法，请按如下格式添加注解：

```java
@Trigger(from = "S1", to = { "S2", "S3" })
@Trigger(from = "S2", to = "S3")
void triggerMethod() {
    // some code here...
}
```

该示例表示了triggerMethod是一个触发器， 可以将状态从S1转移到S2或S3（根据某些其他条件（guard））， 也可以将状态从S2转移到S3。



**关于状态图中Trigger和程序中有@Trigger注解方法一一对应的说明**

- 出现在注解中`from`和`to`中的状态名称，必须与状态图中某个状态的name相同，约定起始状态名为`InitState`，终止状态名为`FinalState`。
- 注解中涉及到的任意一条状态转移路径，在状态图中，都存在一条路径，使得该路径的起始状态与终止状态和注解中的路径一致，trigger函数名与注解标注的函数名一致。
- 图中任意一个迁移的Trigger，都对应程序中的一个添加@Trigger注解的方法，使得Trigger名与方法名一致。



**关于Trigger方法和Guard条件的填写说明**

1. 对于Trigger方法，只需要填写成形如`funcName()`形式。**不需要填写所在类名和方法名中的参数**，以免造成评测失败。（在starUML软件中，括号容易在画布中填写失败，可以在右下方`EDITORS`中的`Properties`中填写括号）

2. **请注意，添加Trigger时，请右键Transition，点击add Trigger，修改Trigger的name字段，而非Transition的name字段**

   ![image-20230507090704316](https://laiang8086-test.oss-cn-beijing.aliyuncs.com/images/image-20230507090704316.png)

3. 对于Guard条件表达式，按一般的C语言条件表达式形式填写即可，请填写在Transition的guard字段。其具体形式化约束符合如下的文法：

```bash
   条件表达式 Cond → LOrExp
   逻辑或表达式 LOrExp → LAndExp | LOrExp '||' LAndExp
   逻辑与表达式 LAndExp → EqExp | LAndExp '&&' EqExp
   相等性表达式 EqExp → RelExp | EqExp ('==' | '!=') RelExp
   关系表达式 RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
   加减表达式 AddExp → MulExp | AddExp ('+' | '−') MulExp 
   乘除模表达式 MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp 
   单目运算符 UnaryOp → '+' | '−' | '!'
   一元表达式 UnaryExp → PrimaryExp | UnaryOp UnaryExp
   数值 Number → IntConst
   基本表达式 PrimaryExp → '(' Exp ')' | LVal | Number
   表达式 Exp → LOrExp
   左值 Lval 在本次作业中可以简单理解为变量名（当然在编译理论中它的含义并非如此）
   IntConst → DecimalConst | 0
   DecimalConst → NonzeroDigit | DecimalConst Digit
   NonzeroDigit → 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
   Digit → 0 | NonzeroDigit
```

1. 由于文法的限制，故对于对象的相等，简单用`==`代替`equals()`方法即可。

2. Guard条件中使用的变量忽略类型（无论是基本数据类型还是自定义类）。

3. 无论是Trigger方法还是Guard条件中涉及的变量，忽略其私有性问题。（即不区分`public`，`private`，`protected`）

4. Guard条件中不允许仅出现一个左值`Lval`。

5. 为避免Guard条件过于复杂导致可行域解算耗时太长，Guard条件表达式不得超过40个字符长度。

6. **同学们需要小心在画布上被删掉的状态仍然保留在模型框中。如果要删除的话一定要保证模型框（MODEL EXPLORER）中也删除完毕，不然可能出现未知的状态不可达。**

    

**温馨提示**

上述评测规则和填写说明，一方面是为了检查你的状态图**设计的合理性**，一方面是为了检查你的状态图和你的程序**这两者的一致性**。但同时应该明白，状态图本身仍然**以示意为主**，所以直接从程序中照搬一些诸如if判断语句的条件填成Guard条件可能会使你在完成状态图时遇到困难。事实上，你需要做的是具体分析源码中**哪些方法和变量体现了你写程序前的对状态和状态转移的设计**。如果不存在这样的方法和变量，你也可以在程序中合理定义一些较为过渡性的方法和中间变量来辅助表达。



### **提示与注意**

**文件保存**

* 请将所绘制的类图保存在 uml.mdj 文件中，并放在提交的**根目录**下（比如说与通常存放 Java 源代码 src 文件夹同级），否则将导致评测失败。
* **请确保类图对应的 UMLModel 的 name 字段为 Model** ，否则会导致评测失败。
- 请将**状态图模型**直接放在**MODEL EXPLORER**根节点下，并保持`StateMachine1`和`StatechartDiagram1`的命名不变。（一种操作方法是，右击`uml`，点取`Add Diagram`，并再选择`Statechart Diagram`），否则会导致评测失败。

![](https://s21.ax1x.com/2024/05/26/pklh4R1.png)



**使用 UML 进行设计**

* 完成作业时应先做好相应的设计，绘制 UML 类图后再实现具体代码。当然，代码变化后可以回头更新 UML 图，但不应该在完成代码后直接照着代码来画 UML 图，那样就失去了设计建模的意义。
* 为了保证同学们写代码时的灵活性，在实现具体代码时，可以根据需要在代码中添加 UML 类图中未指明的**属性和方法**，但 UML 图中的属性和方法应在程序中进行实现，具体检查方法请见前文说明。**注意，不要为了画图方便刻意减少代码中类和方法的数量，也不要试图钻规则的空子，请同学们认真完成作业。**
* UML 建模工具一般都采用了模型和视图相分离的管理方式，即类图中看到的内容实际是对模型的观察。因此，在类图中简单删除一个要素并不一定导致模型发生变化。在完成本次作业过程中，建议同学们要注意阅读 mdj 代码检查各字段是否符合预期，例如检查是否存在仅删去视图未删去元素本身的情况。
* 对于 UML 类图中的方法参数，请保证其在 mdj 文件中的先后顺序与程序中的一致。另外，除了构造方法，每一个方法的 RETURN 类参数应有且仅有一个。

**公测与强测**

**关于公测与强测的图评测说明**：为保证公测与强测中的图评测存在一定的难度差异，现有说明如下：

- 公测与强测中的图评测检查项是**相同的**。
- 公测中对于**属性和方法的一致性，以及关联关系检查**，即使存在错误也**不会判错**，但会在**解释信息**中给出一个导致该错误的原因。
- **不会判错**也即它在公测中被视作是正确的，不会影响进入强测。但是在强测中，如若存在错误则会被视作未通过该检查项。
- 请同学们在公测中仔细查看解释信息，若全都显示“通过”，则表明该项检查项真正通过。
- 请不要过度依赖评测机，发现错误原因后及时修改同质 bug ，避免因超出无代价提交次数而扣分。

由于对于 UML 图的检查以及对于设计的评判较为复杂灵活，本评测仅为判断同学们设计合理的必要条件。即通过评测的 UML 图和程序在此次作业中即被认为通过，但不代表同学的设计和实现没有其它隐藏问题，也不代表就已经是十分优秀的设计。鼓励同学们在完成作业的基础上，进一步了解 UML 图更多规则，以及学习一些设计模式。

## 第五部分：输入输出

### 一、程序输入

程序输入由**两部分**组成：**图书馆初始书目信息**和**用户请求动态信息**。

输入第一行为一个正整数 n，代表图书馆中共有 n 种不同的图书。

接下来 n 行每行对应一种书的详细信息，格式为“**类别号-序列号 副本数**”，例如 "B-0001 10" 代表 B 类下序号为 0001 的书（即书号为B-0001的书）馆藏 10 个副本。序列号为**四位数字**。输入保证不存在相同的 “类别号-序列号”，不同类别号下可以存在相同的序列号，每个书号的书最多 10 个副本。

接下来若干行每行对应一条动态信息，格式为**"[YYYY-mm-dd] OPEN"**和**"[YYYY-mm-dd] CLOSE"**之间的若干条**"[YYYY-mm-dd] <学号> <操作> <类别号-序列号>"**，代表在日期为 [YYYY-mm-dd] 的当天，用户 <学号> 对图书 <类别号-序列号> 进行 <操作>。评测的初始数据点中，除开馆指令和闭馆指令，设评测给定的指令条数为m（即不包含交互式评测生成的指令条数）。

**请注意，初始数据点是给评测机的原始输入，并不等于同学们的程序实际接收到的输入。但我们保证同学们的程序接收到的输入，输入指令中操作的书籍编号，一定在图书馆中存在**。也就是说，对于测试数据点中原有的请求，评测机会根据书籍当前状态（非正式/正式）**自动转换**输入中的书籍类别，以保证不会出现当前图书馆中不存在的书籍。

**新增**：对于捐献请求，保证捐献书籍的序列号**与图书馆初始书籍均不相同**，且**同书号的书最多被捐献1次**。

在评测数据中，所有请求指令都位于当日的开馆指令和闭馆指令之间，对于没有任何指令的日期，评测数据可能省略开闭馆指令。形式化的限制如下：
* 数据的所有指令时间严格不减（不可能出现时间倒流的情况）。
* 对于任意开馆指令 A ，存在且仅存在一条相同日期的闭馆指令 B ，且 B 位于 A 之后；对于任意闭馆指令 P ，存在且仅存在一条相同日期的开馆指令 Q ，且 Q 位于 P 之前。
* 对于任意请求指令 Q ，保证存在相同日期的开馆指令位于 Q 之前，保证存在相同日期的闭馆指令位于 Q 之后。

**具体的 <操作> 种类**：

- queried：查询。
- borrowed：借书。
- ordered：预约书。
- returned：还书。
- picked：取书。
- renewed：续借。
- donated：捐献。

对于借还书动态信息，输入保证已按时间先后顺序排序。也即同一日期的全部信息，可理解为按照输入出现的顺序依次从早到晚发生。 **在图书馆第1天开馆前**，图书馆的所有书本均位于**书架**上。

1≤n≤100，1≤m≤200。 所有输入事件在 [2024-01-01] 至 [2024-12-31] 之间发生，保证日期合法。

**输入信息展示如下**：

| 场景                   | 输入                                           |
| ---------------------- | ---------------------------------------------- |
| 图书馆开馆时输入       | "[YYYY-mm-dd] OPEN"                            |
| 图书馆闭馆时输入       | "[YYYY-mm-dd] CLOSE"                           |
| 用户查询书籍信息时输入 | "[YYYY-mm-dd] <学号> queried <类别号-序列号>"  |
| 用户借书时输入         | "[YYYY-mm-dd] <学号> borrowed <类别号-序列号>" |
| 用户预约时输入         | "[YYYY-mm-dd] <学号> ordered <类别号-序列号>"  |
| 用户还书时输入         | "[YYYY-mm-dd] <学号> returned <类别号-序列号>" |
| 用户取书时输入         | "[YYYY-mm-dd] <学号> picked <类别号-序列号>"   |
| 用户续借时输入         | "[YYYY-mm-dd] <学号> renewed <类别号-序列号>"   |
| 用户捐赠时输入         | "[YYYY-mm-dd] <学号> donated <类别号-序列号>"   |

### 二、程序输出

当程序运行时发生表格中出现的场景时，要求输出相应信息。每条信息占一行。

**开馆时**：

| 场景                   | 输出                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 用户查询书籍信息时输出 | "[YYYY-mm-dd]  <类别号-序列号> <可借阅余本数>"               |
| 用户借书成功时输出     | "[YYYY-mm-dd] [accept] <学号> borrowed <类别号-序列号>"      |
| 用户借书失败时输出     | "[YYYY-mm-dd] [reject] <学号> borrowed <类别号-序列号>"      |
| 用户预约成功时输出     | "[YYYY-mm-dd] [accept] <学号> ordered <类别号-序列号>"       |
| 用户预约失败时输出     | "[YYYY-mm-dd] [reject] <学号> ordered <类别号-序列号>"       |
| 用户还书成功时输出     | "[YYYY-mm-dd] [accept] <学号> returned <类别号-序列号> [overdue \| not overdue]" |
| 用户取书成功时输出     | "[YYYY-mm-dd] [accept] <学号> picked <类别号-序列号>"        |
| 用户取书失败时输出     | "[YYYY-mm-dd] [reject] <学号> picked <类别号-序列号>"        |
| 用户续借成功时输出     | "[YYYY-mm-dd] [accept] <学号> renewed <类别号-序列号>"       |
| 用户续借失败时输出     | "[YYYY-mm-dd] [reject] <学号> renewed <类别号-序列号>"       |
| 用户捐献成功时输出     | "[YYYY-mm-dd] [accept] <学号> donated <类别号-序列号>"       |

要求输出按照时间先后顺序排序。也即同一日期的全部信息，输出的顺序应与事件发生的先后顺序相同。

某日处理开馆后请求的输出，只应出现在当日开馆后，当日闭馆前。

**注意**：使用官方包的同学可以从**stderr**获取完整输入，不使用官方包自行处理输入输出的同学可以根据需要向stderr打印信息，或根据输出反推输入。

**整理时**：

接收到开馆指令OPEN和闭馆指令CLOSE以后，需要输出一个整数k作为准备进行的书籍移动次数，接下来输出k行，每行一条图书移动信息。

本次作业中，我们规定书籍移动的起点和终点只能为如下三种：

- bookshelf (简写作 bs) ：书架
- borrow and return office (简写作 bro) ：借还处
- appointment office (简写作 ao) ：预约处
- book drift corner (简写作 bdc)：图书漂流角

**注意：起点和终点不能相同**

| 场景                     | 输出                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 图书移动，终点不为预约处 | "[YYYY-mm-dd]  move <类别号-序列号> from <起点> to <终点>"   |
| 图书移动，终点为预约处   | "[YYYY-mm-dd]  move <类别号-序列号> from <起点> to <终点> for <学号>" |

图书转运路径的输出，应当紧接在开馆后和闭馆后。

**新增**：将AU，BU，CU类图书转移至书架**后**，将成为对应的ABC类图书，原非正式图书视作消失。但在本次move输出时，仍输出**原类别号（[A|B|C]U）**。



### 三、样例

| 输入                                                         | 输出                                                         | 说明                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------- |
| 1<br/>B-0000 3<br/>[2024-01-01] OPEN<br/>[2024-01-01] 22370002 borrowed B-0000<br/>[2024-01-01] 22370003 borrowed B-0000<br/>[2024-01-01] CLOSE<br/>[2024-01-30] OPEN<br/>[2024-01-30] 22370002 renewed B-0000<br/>[2024-01-30] CLOSE<br/>[2024-02-05] OPEN<br/>[2024-02-05] 22370002 returned B-0000<br/>[2024-02-05] 22370003 returned B-0000<br/>[2024-02-05] CLOSE | 0<br/>[2024-01-01] [accept] 22370002 borrowed B-0000<br/>[2024-01-01] [accept] 22370003 borrowed B-0000<br/>0<br/>0<br/>[2024-01-30] [accept] 22370002 renewed B-0000<br/>0<br/>0<br/>[2024-02-05] [accept] 22370002 returned B-0000 not overdue<br/>[2024-02-05] [accept] 22370003 returned B-0000 overdue<br/>0 | 展示了逾期归还与续借的情况 |
| 1<br/>B-0000 1<br/>[2024-01-05] OPEN<br/>[2024-01-05] 22370001 donated BU-0001<br/>[2024-01-05] 22370010 ordered BU-0001<br/>[2024-01-05] CLOSE<br/>[2024-01-06] OPEN<br/>[2024-01-06] 22370002 borrowed BU-0001<br/>[2024-01-06] 22370002 returned BU-0001<br/>[2024-01-06] CLOSE<br/>[2024-01-07] OPEN<br/>[2024-01-07] 22370003 borrowed BU-0001<br/>[2024-01-07] 22370003 returned BU-0001<br/>[2024-01-07] CLOSE | 0<br/>[2024-01-05] [accept] 22370001 donated BU-0001<br/>[2024-01-05] [reject] 22370010 ordered BU-0001<br/>0<br/>0<br/>[2024-01-06] [accept] 22370002 borrowed BU-0001<br/>[2024-01-06] [accept] 22370002 returned BU-0001 not overdue<br/>1<br/>[2024-01-06] move BU-0001 from bro to bdc<br/>0<br/>[2024-01-07] [accept] 22370003 borrowed BU-0001<br/>[2024-01-07] [accept] 22370003 returned BU-0001 not overdue<br/>1<br/>[2024-01-07] move BU-0001 from bro to bs | 展示了图书漂流相关流程     |





## 第六部分：提示与警示

### 一、提示

同学们可以使用课程组提供的官方包完成输入输出解析，格式化输出等功能。官方包的公开方法均写有Java Doc注释，可以在IDEA中查看。官方包详细使用说明敬见讨论区。

对于交互式评测，使用官方包时，一次读入方法，必须调用且仅调用一次输出方法。

本单元聚焦于UML正向建模与设计，且不安排互测，也没有性能分。同学们无需刻意考虑各种边界情况，只需自行设计合理的图书整理策略与系统运行逻辑，不存在明显不合常理的行为，即可通过评测。

### 二、警示

请不要hack评测机！oo课程组感谢大家做出的贡献！
